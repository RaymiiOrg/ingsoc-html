
    <!DOCTYPE html>
    <html lang="en">
        <head>
        <title>C++ std::async with a concurrency limit (via semaphores) - Raymii.org</title>
        <style>*,::before,::after{background-color:white;background-repeat:no-repeat;-webkit-box-sizing:border-box;box-sizing:border-box}::before,::after{text-decoration:inherit;vertical-align:inherit}html{cursor:default;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.15;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;word-break:break-word}body{margin:0}h1{font-size:2em;margin:.67em 0}hr{height:0;overflow:visible}main{display:block}nav ol,nav ul{list-style:none}pre{font-family:Menlo,Consolas,Roboto Mono,Ubuntu Monospace,Noto Mono,Oxygen Mono,Liberation Mono,monospace;font-size:1em}a{background-color:transparent}abbr[title]{text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:Menlo,Consolas,Roboto Mono,Ubuntu Monospace,Noto Mono,Oxygen Mono,Liberation Mono,monospace;font-size:1em}small{font-size:80%}::-moz-selection{background-color:#b3d4fc;color:#000;text-shadow:none}::selection{background-color:#b3d4fc;color:#000;text-shadow:none}audio,canvas,iframe,img,svg,video{vertical-align:middle}audio,video{display:inline-block}audio:not([controls]){display:none;height:0}img{border-style:none}svg:not([fill]){fill:currentColor}svg:not(:root){overflow:hidden}table{border-collapse:collapse}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}button,input,select{margin:0}button{overflow:visible;text-transform:none}button,[type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button}fieldset{padding:.35em .75em .625em}input{overflow:visible}legend{color:inherit;display:table;max-width:100%;white-space:normal}progress{display:inline-block;vertical-align:baseline}select{text-transform:none}textarea{margin:0;overflow:auto;resize:vertical}[type="checkbox"],[type="radio"]{padding:0}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}details{display:block}dialog{background-color:white;border:solid;color:black;display:block;height:-moz-fit-content;height:-webkit-fit-content;height:fit-content;left:0;margin:auto;padding:1em;position:absolute;right:0;width:-moz-fit-content;width:-webkit-fit-content;width:fit-content}dialog:not([open]){display:none}summary{display:list-item}canvas{display:inline-block}template{display:none}a,area,button,input,label,select,summary,textarea,[tabindex]{-ms-touch-action:manipulation;touch-action:manipulation}[hidden]{display:none}[aria-busy="true"]{cursor:progress}[aria-controls]{cursor:pointer}[aria-disabled="true"],[disabled]{cursor:not-allowed}[aria-hidden="false"][hidden]:not(:focus){clip:rect(0,0,0,0);display:inherit;position:absolute}main,header,footer,article,section,aside,details,summary{margin:0 auto;margin-bottom:16px;width:100%}main{display:block;margin:0 auto;max-width:1000px;padding:0 16px 16px}footer{border-top:1px solid rgba(0,0,0,.12);padding:16px 0;text-align:left}footer p{margin-bottom:0}hr{border:0;border-top:1px solid rgba(0,0,0,.12);display:block;margin-top:16px;margin-bottom:16px;width:100%;-webkit-box-sizing:content-box;box-sizing:content-box;height:0;overflow:visible}img{height:auto;max-width:100%;vertical-align:baseline}@media screen and (max-width:400px){article,section,aside{clear:both;display:block;max-width:100%}img{margin-right:16px}}embed,iframe,video{border:0}body{color:rgba(0,0,0,.8);font-family:"Raleway",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:16px;line-height:1.5}p{margin:0;margin-bottom:16px}h1,h2,h3,h4,h5,h6{color: inherit;font-family:inherit;line-height:1.2;font-weight:500}h1{font-size:40px;margin:20px 0 16px}h2{font-size:32px;margin:20px 0 16px}h3{color: #75cc00;font-size:28px;margin:16px 0 4px}h4{color: #75cc00;font-size:24px;margin:16px 0 4px}h5{color: #75cc00;font-size:20px;margin:16px 0 4px}h6{color: #75cc00;font-size:16px;margin:16px 0 4px}small{color:rgba(0,0,0,.54);vertical-align:bottom}pre{background:#f7f7f9;color:rgba(0,0,0,.8);display:block;font-family:Menlo,Monaco,Consolas,"Courier New",monospace;font-size:16px;margin:16px 0;padding:16px;white-space:pre-wrap;overflow-wrap:break-word}code{background: #f7f7f9;color:rgba(0,0,0,.8);font-family:Menlo,Monaco,Consolas,"Courier New",monospace;font-size:16px;line-height:inherit;margin:0;padding:4px;vertical-align:baseline;word-break:break-all;word-wrap:break-word}a{color:#75cc00;text-decoration:none;background-color:transparent}a:hover,a:focus{color:#0062cc;text-decoration:underline}dl{margin-bottom:16px}dd{margin-left:40px}ul,ol{margin-bottom:8px;padding-left:40px;vertical-align:baseline}blockquote{border-left:2px solid rgba(0,0,0,.8);font-family:Georgia,Times,"Times New Roman",serif;font-style:italic;margin:16px 0;padding-left:16px}figcaption{font-family:Georgia,Times,"Times New Roman",serif}u{text-decoration:underline}s{text-decoration:line-through}sup{font-size:14px;vertical-align:super}sub{font-size:14px;vertical-align:sub}mark{background:#ffeb3b}input[type="text"],input[type="password"],input[type="email"],input[type="url"],input[type="date"],input[type="month"],input[type="time"],input[type="datetime"],input[type="datetime-local"],input[type="week"],input[type="number"],input[type="search"],input[type="tel"],select,textarea{background:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.12);border-radius:4px;color:rgba(0,0,0,.8);display:block;width:100%;padding:8px 16px;line-height:1.5;-webkit-transition:border-color .15s ease-in-out,-webkit-box-shadow .15s ease-in-out;transition:border-color .15s ease-in-out,-webkit-box-shadow .15s ease-in-out;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out,-webkit-box-shadow .15s ease-in-out;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}input[type="color"]{background:#fff;border:1px solid rgba(0,0,0,.12);border-radius:4px;display:inline-block;vertical-align:middle}input:not([type]){-webkit-appearance:none;background:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.12);border-radius:4px;color:rgba(0,0,0,.8);display:block;width:100%;padding:8px 16px;line-height:1.5;-webkit-transition:border-color .15s ease-in-out,-webkit-box-shadow .15s ease-in-out;transition:border-color .15s ease-in-out,-webkit-box-shadow .15s ease-in-out;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out,-webkit-box-shadow .15s ease-in-out;text-align:left}input[type="text"]:focus,input[type="password"]:focus,input[type="email"]:focus,input[type="url"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="time"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,input[type="week"]:focus,input[type="number"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="color"]:focus,select:focus,textarea:focus{background-color:#fff;border-color:#80bdff;outline:0;-webkit-box-shadow:0 0 0 .2rem rgba(0,123,255,.25);box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}input:not([type]):focus{background-color:#fff;border-color:#80bdff;outline:0;-webkit-box-shadow:0 0 0 .2rem rgba(0,123,255,.25);box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:1px thin rgba(0,0,0,.12)}input[type="text"][disabled],input[type="password"][disabled],input[type="email"][disabled],input[type="url"][disabled],input[type="date"][disabled],input[type="month"][disabled],input[type="time"][disabled],input[type="datetime"][disabled],input[type="datetime-local"][disabled],input[type="week"][disabled],input[type="number"][disabled],input[type="search"][disabled],input[type="tel"][disabled],input[type="color"][disabled],select[disabled],textarea[disabled]{background-color:rgba(0,0,0,.12);color:rgba(0,0,0,.54);cursor:not-allowed;opacity:1}input:not([type])[disabled]{background-color:rgba(0,0,0,.12);color:rgba(0,0,0,.54);cursor:not-allowed;opacity:1}input[readonly],select[readonly],textarea[readonly]{border-color:rgba(0,0,0,.12);color:rgba(0,0,0,.54)}input:focus:invalid,textarea:focus:invalid,select:focus:invalid{border-color:#ea1c0d;color:#f44336}input[type="file"]:focus:invalid:focus,input[type="radio"]:focus:invalid:focus,input[type="checkbox"]:focus:invalid:focus{outline-color:#f44336}select{border:1px solid rgba(0,0,0,.12);vertical-align:sub}select:not([size]):not([multiple]){height:-webkit-calc(2.25rem + 2px);height:calc(2.25rem + 2px)}select[multiple]{height:auto}label{display:inline-block;line-height:2}fieldset{border:0;margin:0;padding:8px 0}legend{border-bottom:1px solid rgba(0,0,0,.12);color:rgba(0,0,0,.8);display:block;margin-bottom:8px;padding:8px 0;width:100%}textarea{overflow:auto;resize:vertical}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;box-sizing:border-box;padding:0;display:inline}input[type=submit],input[type=reset],input[type=button],button{background-color:#75cc00;border:#75cc00;border-radius:4px;color:#fff;padding:8px 16px;display:inline-block;font-weight:400;text-align:center;white-space:nowrap;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:1px solid transparent;font-size:1rem;line-height:1.5;-webkit-transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,-webkit-box-shadow .15s ease-in-out;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,-webkit-box-shadow .15s ease-in-out;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out,-webkit-box-shadow .15s ease-in-out}input[type=submit]::-moz-focus-inner,input[type=reset]::-moz-focus-inner,input[type=button]::-moz-focus-inner,button::-moz-focus-inner{padding:0}input[type=submit]:hover,input[type=reset]:hover,input[type=button]:hover,button:hover{background-color:#0069d9;border-color:#0062cc;color:#fff}input[type=submit]:not(:disabled):active,input[type=reset]:not(:disabled):active,input[type=button]:not(:disabled):active,button:not(:disabled):active{background-color:#0062cc;border-color:#005cbf;color:#fff}input[type=submit]:focus,input[type=reset]:focus,input[type=button]:focus,button:focus{outline:0;-webkit-box-shadow:0 0 0 .2rem rgba(0,123,255,.5);box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}input[type=submit]:disabled,input[type=reset]:disabled,input[type=button]:disabled,button:disabled{opacity:.65;cursor:not-allowed;background-color:#75cc00;border-color:#75cc00;color:#fff}table{border-top:1px solid rgba(0,0,0,.12);margin-bottom:16px}caption{padding:8px 0}thead th{border:0;border-bottom:2px solid rgba(0,0,0,.12);text-align:left}tr{margin-bottom:8px}th,td{border-bottom:1px solid rgba(0,0,0,.12);padding:16px;white-space:nowrap;vertical-align:inherit}tfoot tr{text-align:left}tfoot td{color:rgba(0,0,0,.54);font-size:8px;font-style:italic;padding:16px 4px}a.skip-main{left:-999px;position:absolute;top:auto;width:1px;height:1px;overflow:hidden;z-index:-999}a.skip-main:focus,a.skip-main:active{color:#fff;background-color:#000;left:auto;top:auto;width:30%;height:auto;overflow:auto;margin:10px 35%;padding:5px;border-radius:15px;border:4px solid yellow;text-align:center;font-size:1.2em;z-index:999}@font-face{font-family:'Raleway';font-display: swap;font-style:normal;font-weight:400;src:url(/s/inc/css/raleway.eot);src:local('Raleway'),local('Raleway'),url(/s/inc/css/raleway.ttf)}.headheader{font-family:"Raleway"!important}.headheader a{color:#000;text-decoration:none}.headheader a:hover{color:#000;text-decoration:none!important}#toc ul {list-style: none; margin: 0; padding: 0;} #toc h3{ color: black;} </style>
        <script> </script>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="application/opensearchdescription+xml" rel="search" href="/s/inc/opensearch.xml"/>
        <link rel="alternate" type="application/rss+xml" title="RSS Feed for Raymii.org" href="https://raymii.org/s/feed.xml" />
    </head>
    <body>
        
        <a id="top-of-page"></a>
        <main>
        <a class="skip-main" href="#main">Skip to main content</a>
            <header>
                <h1 class="headheader">
                    <a href="https://raymii.org/s/">Raymii.org 
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAKCAYAAAD2Fg1xAAABgElEQVQ4jb3VP0iVYRTH8c9waXBokog7OYhTXChuF3GIi4hoiJA4REQIOTgGtoWTg6ODs0SYComIXCJEMhpKtD9guUU0ujRFS0PQ8DzC24v3Pq+3S9/pnMOP8/7Ocx6el/OziRN0JXTD+I2xhK4WdeNteGmbu8IgC3jQQlfCZ0zgINHzJabwoQP+ClHGV1zGJXwRDJ/FDJZi3MBQE10dL2K8gZFOGE3REDZyyjLunKG7KAzZHfMaXjXp+QbXYlzBfrvmSuhBNaHrxQU8zdQW8RhrOe0snuB7zA/jd6p4n9HV8QMfY/4JPzGAt7meFfS18LdXEk7uemIQuJ/Lj6PZQezFWhm3cTWnXcAj3MrU5oWh5WpzGM3UurGNZy28HSa8J7mB3Uy+4u/rl+UdrsT4Jraa6F6jP5M3MP0PHguzL9zzqmC2GRNYjXF2qDzDwgbgHp53wGMhJrEunGQ9oT3CQ+GFasWBsLVvwiv5XygJz/JOAe208POrJHST+CVspBB/AFY9Q3+QJqLxAAAAAElFTkSuQmCC" alt="Raymii.org Logo">
                    </a>
                </h1>
                <small>
                  Quis custodiet ipsos custodes?<br>
                  <a href="/s/">Home</a> | 
                  <a href="/s/static/About.html">About</a> | 
                  <a href="/s/tags/all.html">All pages</a> | 
                  <a href="https://raymii.org/s/feed.xml">RSS Feed</a> | 
                  <a href="gopher://raymii.org:70">Gopher</a>
                </small>
            </header>
          
    <h2 class='headheader' id='main'>C++ std::async with a concurrency limit (via semaphores)</h2>
<p><small>Published: 11-01-2021 | Author: Remy van Elst | <a href="Cpp_std_async_with_a_concurrency_limit.txt">Text only version of this article</a>
</small></p>
<div class='ad'>
                            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                            <ins class="adsbygoogle"
                                 style="display:inline-block;width:728px;height:90px"
                                 data-ad-client="ca-pub-7993642564731324"
                                 data-ad-slot="6172324376"></ins>
                            <script>
                            (adsbygoogle = window.adsbygoogle || []).push({});
                            </script>
                        </div><br><div id="toc">
<h3>Table of Contents</h3>
<ul>
<li>
<a href="#toc_0">Mutexes and Semaphores</a>
</li>
<li>
<a href="#toc_1">Project setup</a>
</li>
<li>
<a href="#toc_2">Queue up jobs and wait until they&#39;re all finished</a>
</li>
<li>
<a href="#toc_3">Job queue with a concurrency limit</a>
</li>
</ul>

</div>
<hr>
<div id="contents">
<p><img src="/s/inc/img/semafoor.jpg" alt="Semafoor"></p>

<blockquote>
<p>Semafoor en Dommel</p>
</blockquote>

<p><code>std::async</code> is an easy way to do multiple things concurrently, without the
hurdle of manual thread management in C++. Like batch converting images,
database calls, http requests, you name it. Create a few <code>std::futures</code> and
later on when they&#39;re ready, <code>.get()</code> &#39;m while they&#39;re still hot. A <code>future</code>
is an object which handles the synchronization and guarantees that the results
of the invocation are ready. If you <code>.get()</code> it and it&#39;s not ready, it will block.</p>

<p>Recently I had a use case for concurrency with a limit. I needed to do hundreds
of <a href="/s/software/Cpp_exercise_in_parsing_json_http_apis_and_time_stuff.html">HTTP calls to a JSON API</a>. The concurrency limit was not for the hardware,
but for the server on the other side. I didn&#39;t want to hammer it with requests. 
But you can also imagine that you&#39;re converting images or other &quot;heavy&quot; processes 
which might be taxing for the hardware. If in doubt, always benchmark. </p>

<p><img src="/s/inc/img/cpp-async-4.png" alt="screenshot"></p>

<blockquote>
<p>The end result, async tasks with a concurrency limit</p>
</blockquote>

<p>There is no standard way to limit the amount of concurrent jobs via <code>std::async</code>. 
You can fire of a hundred jobs and it is up to the implementation to not fry the 
hardware. On linux/gcc it will probably use a thread pool so you&#39;re lucky, but
you cant assume that. </p>

<p>This article will show you a simple short solution to implement a concurrency
limit together with std::async, by using a <a href="https://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore</a>, implemented with 
modern (C++ 11) standard library features (<code>std::mutex</code>, <code>std::condition_variable</code> and such).</p>

<p>We start off with a shorter example showing how to fire off a set number of jobs 
and wait until all of those are finished before continuing. That is very useful
if you have a set number of jobs and want the implementation to handle all the 
thread work for you.</p>

<p><a href="https://www.digitalocean.com/?refcode=7435ae6b8212">If you like this article, consider sponsoring me by trying out a Digital Ocean
VPS. With this link you&#39;ll get $100 credit for 60 days). (referral link)</a></p>

<p>I was introduced to <a href="https://www.youtube.com/watch?v=3ENV48XgxMU">Semafoor</a> in my childhood by the Dutch (Belgian)
cartoon <a href="https://en.wikipedia.org/wiki/Cubitus">Dommel</a>, or <code>Cubitus</code> in the USA. The series tells the story of
Cubitus, a good-natured large, white dog endowed with speech. He lives in a
house in the suburbs with his master, Semaphore, a retired sailor, next door
to Senechal, the black and white cat who is Cubitus&#39; nemesis. </p>

<p>If you need these &quot;advanced&quot; concurrency features you could also just resort to 
<a href="/s/articles/Cpp_async_threads_and_user_input.html">manual thread management</a>. However, that is quite a bit more work to pull
off and for simple use cases <code>std::async</code> is just easier and simpler to setup and 
use. This Semaphore adds a bit of complexity, but IMHO it&#39;s worth it, small enough
and still better than manual thread management.</p>

<h3 id="toc_0">Mutexes and Semaphores</h3>

<p>Mutexes (mutual exclusion) and semaphores are similar in use and are often
used interchangeably. I&#39;ll try to explain a the meaning in our C++ setup.</p>

<p>First a bit on what they share. Both a semaphore and a mutex are constructs
that blocks execution of threads under certain conditions. Most often they 
are used in a &quot;critical section&quot; of code, that can have only one (or only a few)
threads working on it at a time. </p>

<p>When a mutex or semaphore is available, a thread can acquire (lock) the mutex
or semaphore and continue executing the &quot;critical section&quot;.  </p>

<p>When a mutex or semaphore is not available (locked), a thread is blocked from
further execution when it wants to acquire/lock it.  Threads that have acquired a
mutex or semaphore must release it so another thread can (eventually) acquire
it again. If that does not happen or if threads are waiting on one another, there
is a deadlock.</p>

<p>The difference between a mutex and a semaphore is in our case that only one
thread at a time can acquire a mutex, but some preset number of threads can
concurrently acquire a semaphore. </p>

<p>A semaphore is used for flow control / signaling, (to restrict the number of
threads executing the critical section).</p>

<p>In our case, the semaphore has a limit of 4, so when 4 threads have acquired
the semaphore, new threads must wait (are blocked) until the semaphore is available
again (once one of the 4 releases it). The waiting is all handled by C++ language
constructs (<code>condititon_variable</code>, <code>lock_guard</code>)</p>

<p>By using <code>RAII</code>, we can create an object named <code>CriticalSection</code>, 
which acquires the semaphore when it is constructed (comes into scope) and 
releases it when it is destructed (goes out of scope). Very handy since that
way you can never forget to manually release the semaphore.</p>

<h3 id="toc_1">Project setup</h3>

<p>For this guide I assume you&#39;re running on a Linux system with <code>gcc</code> and <code>cmake</code>.
This is my <code>CMakeLists.txt</code> file:</p>

<pre><code>cmake_minimum_required(VERSION 3.17)
project(async-with-max-concurrency)

set(CMAKE_CXX_STANDARD 11)

find_package(Threads REQUIRED)
set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pthread&quot; )

add_executable(async-with-max-concurrency main.cpp)
</code></pre>

<p>As always with cMake projects, create a build folder and configure cmake:</p>

<pre><code>mkdir build
cd build
cmake ..
</code></pre>

<p>If you are ready to build the project, do a <code>make</code> in that folder:</p>

<pre><code>make
</code></pre>

<p>The binary is located in the same build folder:</p>

<pre><code>./async-with-max-concurrency
</code></pre>

<h3 id="toc_2">Queue up jobs and wait until they&#39;re all finished</h3>

<p>This is a simpler example to get us started. Imagine yourself having to 
get 15 JSON API endpoints, <code>/api/v1/page/0.json</code> up to <code>14.json</code> to 
process that information. You could write a for loop, which is fine 
and simple. Doing 15 HTTP calls takes a few seconds, if one of them 
is slow, the entire gathering part is slower overall. Wouldn&#39;t it be 
nice if you could fetch those 15 pages at once? One slow page doesn&#39;t
slow the entire process down much. </p>

<p>Here is where <code>std::async</code> comes to the rescue. You create a bunch of 
<code>std::future</code> objects that do the actual work and fire them off. Once
they&#39;re all finished, you can proceed. </p>

<p>This example does not make use of a semaphore or locking, it just fires
off a set number of threads and lets the implementation manages </p>

<p>The code below fills a vector with <code>future</code> objects that return a 
string. It uses a special template function to check if the <code>futures</code>
are ready, and if so, puts the result in another vector. </p>

<p>You can only <code>.get()</code> a future once. If it&#39;s not ready, that call blocks. 
By using this template to check the state of the future, we ensure 
that it is ready when we do the <code>.get()</code>, not blocking our execution.</p>

<pre><code>// main.cpp
template&lt;typename T&gt;
bool isReady(const std::future&lt;T&gt;&amp; f) {
    if (f.valid()) { // otherwise you might get an exception (std::future_error: No associated state)
        return f.wait_for(std::chrono::seconds(0)) == std::future_status::ready;
    } else {
        return false;
    }
}

std::string timeString(std::chrono::system_clock::time_point t, const std::string&amp; format) {
    time_t timepoint_time_t = std::chrono::system_clock::to_time_t(t);
    char buffer[1024];
    struct tm tm {0};
    if (!gmtime_r(&amp;timepoint_time_t, &amp;tm)) return (&quot;Failed to get current date as string&quot;);
    if (!std::strftime(buffer, sizeof(buffer), format.c_str(), &amp;tm)) return (&quot;Failed to get current date as string&quot;);
    return std::string{buffer};
}

int main() {
    int totalJobs = 15;
    std::vector&lt;std::future&lt;std::string&gt;&gt; futures;
    std::vector&lt;std::string&gt; readyFutures;
    // Queue up all the items,
    for (int i = 0; i &lt; totalJobs; ++i) {
        futures.push_back(
            std::async(std::launch::async,
                [&amp;](const std::string&amp; name){
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                       return &quot;Hi &quot; + name + &quot;, I&#39;m an example doing some work at &quot; +
                       timeString(std::chrono::system_clock::now(), &quot;%H:%M:%S&quot;);
               }, std::to_string(i))
        );
    }
    // wait until all are ready
    do {
        for (auto &amp;future : futures) {
            if (isReady(future)) {
                readyFutures.push_back(future.get());
            }
        }
    } while (readyFutures.size() &lt; futures.size());

    for (const auto&amp; result : readyFutures) {
        std::cout &lt;&lt; result &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

<p>If you don&#39;t like lambda&#39;s you can also use variadic arguments to call
another function:</p>

<pre><code>std::string ExampleJob(int tally) {
    return &quot;Hi &quot; + std::to_string(tally) + &quot;, I&#39;m an example doing some work at &quot; + timeString(std::chrono::system_clock::now(), &quot;%H:%M:%S&quot;);
}
// main {}
    futures.push_back(std::async(std::launch::async, ExampleJob, i));
</code></pre>

<p>If you create a <code>std::async</code> this way and want to pass a parameter by
reference, you need to use <code>std::ref()</code> (<a href="http://web.archive.org/web/20210104130103/https://stackoverflow.com/questions/18359864/passing-arguments-to-stdasync-by-reference-fails">read why here</a>). So if you want to
pass a reference  to a string (<code>const std::string&amp; myString</code>), you would do
<code>std::async(std::launch::async, ExampleJob, std::ref(myString))</code>. </p>

<p>The above code results in the below output:</p>

<p><img src="/s/inc/img/cpp-async-3.png" alt="async example 1"></p>

<p>I&#39;ve added a helper function to print a time string. In this example all the &quot;jobs&quot;
run at the same time, but in the next example you should see a delay there. </p>

<p>This example is useful if you have a set number of items you need to work with, or
if you want the implementation to manage all the threads for you. On my workstation
I can queue up 1500 of these example jobs and they all run the same second. 15000 jobs
take 10 seconds to give you an idea.</p>

<h3 id="toc_3">Job queue with a concurrency limit</h3>

<p>This is what you probably came here for so lets get into this job queue with a
concurrency limit. We&#39;re using a <code>std::condition_variable</code> to do all the hard
work for us. Quoting <a href="https://en.cppreference.com/w/cpp/thread/condition_variable">cppreference</a>:</p>

<p>The <code>condition_variable</code> class is a synchronization primitive that
can be used to block a thread, or multiple threads at the same time, until
another thread both modifies a shared variable (the condition), and notifies
the <code>condition_variable</code>.</p>

<p>The purpose of a <code>std::condition_variable</code> is to wait for some
condition to become true. This is important, because you actually do need that
condition to check for <a href="http://web.archive.org/web/20210109071845/https://www.modernescpp.com/index.php/c-core-guidelines-be-aware-of-the-traps-of-condition-variables">lost wakeups and spurious wakeups</a>. </p>

<p>We could also have used a polling loop to implement this waiting, but that would
use <a href="http://web.archive.org/web/20210109072438/https://stackoverflow.com/questions/16350473/why-do-i-need-stdcondition-variable/16350623">way more resources</a> than this, and would probably be more error prone.</p>

<p>How to use the <code>condition_variable</code> is almost spelled out to us on <a href="https://en.cppreference.com/w/cpp/thread/condition_variable">cppreference</a>,
so do go read that. If you&#39;re wondering about the technical details behind using
a <code>unique_lock</code>, <a href="http://web.archive.org/web/20210109072627/https://stackoverflow.com/questions/13099660/c11-why-does-stdcondition-variable-use-stdunique-lock/13102893">this stackoverflow post</a> has the best explanation.</p>

<p>Now onto the code. The first class, the <code>Semafoor</code> (Dommel reference here) does the
actual work, <code>count</code> is it&#39;s max limit of concurrent threads. The second class,
<code>CriticalSection</code>, is a handy dandy <code>RAII</code> wrapper. In its constructor it 
waits for the <code>Semafoor</code> (which in turn, when possible, acquires the lock) and
in its destructor it releases the <code>Semafoor</code> (which in turn, releases the lock). </p>

<p>That translates to, as long as your scope is correct, you never forget to lock or 
unlock the <code>Semafoor</code>. </p>

<pre><code>// main.cpp
class Semafoor {
public:
    explicit Semafoor(size_t count) : count(count) {}
    size_t getCount() const { return count; };
    void notify() {  // call after critical section
        std::unique_lock&lt;std::mutex&gt; lock(mutex);
        ++count;
        condition_variable.notify_one();
    }
    void wait() { // call before critical section
        std::unique_lock&lt;std::mutex&gt; lock(mutex);
        condition_variable.wait(lock, [this] {
          if (count != 0) // written out for clarity, could just be return (count != 0);
              return true;
          else
              return false;
        });
        --count;
    }

private:
    std::mutex mutex;
    std::condition_variable condition_variable;
    size_t count;
};

// RAII wrapper, make on of these in your &#39;work-doing&#39; class to
// lock the critical section. once it goes out of scope the
// critical section is unlocked
class CriticalSection {
public:
    explicit CriticalSection(Semafoor &amp;s) : semafoor{s} {
        semafoor.wait();
    }
    ~CriticalSection() {
        semafoor.notify();
    }
private:
    Semafoor &amp;semafoor;
};

template&lt;typename T&gt;
bool isReady(const std::future&lt;T&gt;&amp; f) {
    if (f.valid()) { // otherwise you might get an exception (std::future_error: No associated state)
        return f.wait_for(std::chrono::seconds(0)) == std::future_status::ready;
    } else {
        return false;
    }
}
std::string timeString(std::chrono::system_clock::time_point t, const std::string&amp; format) {
    time_t timepoint_time_t = std::chrono::system_clock::to_time_t(t);
    char buffer[1024];
    struct tm tm {0};
    if (!gmtime_r(&amp;timepoint_time_t, &amp;tm)) return (&quot;Failed to get current date as string&quot;);
    if (!std::strftime(buffer, sizeof(buffer), format.c_str(), &amp;tm)) return (&quot;Failed to get current date as string&quot;);
    return std::string{buffer};
}


int main() {
    int totalJobs = 15;
    std::vector&lt;std::future&lt;std::string&gt;&gt; futures;
    std::vector&lt;std::string&gt; readyFutures;
    Semafoor maxConcurrentJobs(3);

    // Queue up all the items,
    for (int i = 0; i &lt; totalJobs; ++i) {
        futures.push_back(
            std::async(std::launch::async,
               [&amp;](const std::string&amp; name, Semafoor&amp; maxJobs){
                 CriticalSection w(maxJobs);
                 std::this_thread::sleep_for(std::chrono::seconds(1));
                 return &quot;Hi &quot; + name + &quot;, I&#39;m an example doing some work at &quot; +
                        timeString(std::chrono::system_clock::now(), &quot;%H:%M:%S&quot;);
               }, std::to_string(i), std::ref(maxConcurrentJobs))
        );
    }
    // wait until all are ready
    do {
        for (auto &amp;future : futures) {
            if (isReady(future)) {
                readyFutures.push_back(future.get());
            }
        }
    } while (readyFutures.size() &lt; futures.size());

    for (const auto&amp; result : readyFutures) {
        std::cout &lt;&lt; result &lt;&lt; std::endl;
    }
}
</code></pre>

<p>In <code>main()</code> not much has changed. We create a <code>Semafoor</code> with a concurrent limit of 3, pass <a href="http://web.archive.org/web/20210104130103/https://stackoverflow.com/questions/18359864/passing-arguments-to-stdasync-by-reference-fails">a reference</a> to that
into the lambda, and, most important, when our work starts we create a <code>CriticalSection</code> object, that acquires the 
<code>Semafoor</code> or waits until it is available. When that goes out of scope, the <code>Semafoor</code> is released.</p>

<p>If you use this code, you can put your own critical section in <code>{}</code> (curly brackets) to limit that scope:</p>

<pre><code>some();
code();
{ // scope starts
    CriticalSection w(SemafoorRef); // Semafoor acquired
    do();
    work();
} // scope ends there, Semafoor released
more();
code();
</code></pre>

<p>If you don&#39;t want to use a lambda you can pass a function when creating the <code>std::future</code>, but the <code>Semafoor</code> 
has to be a reference (they all must use the same <code>Semafoor</code>), thus we <a href="http://web.archive.org/web/20210104130103/https://stackoverflow.com/questions/18359864/passing-arguments-to-stdasync-by-reference-fails">need to pass a</a> <code>std::ref()</code>, like so:</p>

<pre><code>std::string exampleJob(int tally, Semafoor&amp; maxJobs) {
    CriticalSection w(maxJobs);
    std::this_thread::sleep_for( std::chrono::seconds(1));
    return &quot;Hi &quot; + std::to_string(tally) + &quot;, I&#39;m an example doing some work at &quot; + timeString(std::chrono::system_clock::now(), &quot;%H:%M:%S&quot;);
}
[...]
futures.push_back(std::async(std::launch::async, exampleJob, i, std::ref(maxConcurrentJobs)));
</code></pre>

<p>The code outputs the following:</p>

<p><img src="/s/inc/img/cpp-async-4.png" alt="code screenshot"></p>

<p>As you can see, the timestamps now have a second between them each 3 jobs, just as we said.
The <code>Semafoor</code> has a max concurrency limit of 3, which the code and output reflect. Only
3 jobs are running at the same time. You must make sure to use the same semaphore everywhere,
otherwise you&#39;ll be copying one and each instance has their own unique semaphore, which is 
exactly not what we want. </p>

<p>For jobs where you do need some parallelism but need more control than <code>std::async</code> provides you,
whilst not having to result to manual threads, using this semaphore construction gives you 
just enough control. In the case of my HTTP requests, I didn&#39;t overload the server but 
limited the requests to 15, but you can think of many more use cases (converting files, database 
actions, you name it).</p>
Tags: <a href="../tags/async.html">async</a>
, <a href="../tags/c++.html">c++</a>
, <a href="../tags/cmake.html">cmake</a>
, <a href="../tags/cpp.html">cpp</a>
, <a href="../tags/development.html">development</a>
, <a href="../tags/mutex.html">mutex</a>
, <a href="../tags/semaphore.html">semaphore</a>
, <a href="../tags/threads.html">threads</a>
, <a href="../tags/tutorials.html">tutorials</a>
</div>
<br/>
<footer>
<br/>
                <form role="search" action="https://encrypted.google.com/search"
                style="min-width:250px;max-width:300px;">
                    <div class="form-group">
                      <input type="hidden" name="as_sitesearch" value="raymii.org">
                      <input type="hidden" name="as_qdr" value="all">
                      <input type="text" name="as_q" class="form-control" placeholder="Search">
                    </div>
                  </form>
                <br>
                <p><small>
                <a href="/s/">Home</a> | 
                <a href="/s/static/About.html">About</a> | 
                <a href="/s/tags/all.html">All pages</a> | 
                <a href="/s/software/Sparkling_Network.html">Cluster Status</a> | 
                Generated by <a href="/s/software/ingsoc.html">ingsoc</a>.</small>
                </p>
    
    </footer>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-3704876-6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-3704876-6');
    </script>
     
    </main>
    </body>
    </html>
    